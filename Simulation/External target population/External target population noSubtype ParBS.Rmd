---
title: "External target population no subtype ParBS"
author: "Qi Wang"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if(!require(XSRecency)){
  devtools::install("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/XSRecency-pt-functions") 
}
```

# Generating panel data for crossSecing population
```{r}
library(XSRecency)
library(geepack)
library(data.table)
library(dplyr)
YEAR2DAY=365.25

get.phi.function = function(window.period, shadow.period, phi_tfrr = NULL, 
                            phi_frr = NULL, phi_norm_mu = NULL, phi_norm_sd = NULL, 
                            phi_norm_div = NULL, phi_pnorm_mu = NULL, phi_pnorm_sd = NULL, 
                            phi_pnorm_div = NULL){
  # Get the gamma parameters and baseline phi function
  params = get.gamma.params(window=window.period/YEAR2DAY, shadow=shadow.period/YEAR2DAY)
  # Set up each type of phi function, will be overwritten
  phi.none = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phi.const = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phi.norm = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phit.pnorm = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  
  phi.func = phi.none
  
  # Get the phi function with constant FRR either past a certain time
  # or fixed after it hits some value.
  if(!is.null(phi_tfrr) | !is.null(phi_frr)){
    if(!is.null(phi_tfrr)){
      ttime = phi_tfrr
      tval = phi.none(ttime)
    }
    if(!is.null(phi_frr)){
      tau = 12
      tval = phi_frr
      ttime = uniroot(function(t) phi.none(t) - tval, interval=c(0, tau))$root
      cat(ttime)
    }
    phi.const = function(t, ...) phi.none(t)*(t <= ttime) + tval*(t > ttime)
    phi.func = phi.const
  }
  if(!is.null(phi_norm_mu)){
    phi.norm = function(t) phi.const(t) + dnorm(t-phi_norm_mu, mean=0, sd=phi_norm_sd) / phi_norm_div
    phi.func = phi.norm
  }
  if(!is.null(phi_pnorm_mu)){
    phi.pnorm = function(t) phi.const(t) + pnorm(t-phi_pnorm_mu, mean=0, sd=phi_pnorm_sd) / phi_pnorm_div
    phi.func = phi.pnorm
  }
  return(phi.func)
}


get_panel_crossSec = function(n_sims, sample_size_crossSec, profiles_crossSec, 
                          infection.function, phi.func, bigT_crossSec){
  # Within a column: number of observations of each group of individuals generated by
  # multinomial distribution
  # Different columns are different replications
  num_obs_crossSec = rmultinom(n_sims, size = sample_size_crossSec, prob = profiles_crossSec$Proportion)
  out_panel_datalist = vector("list", length = nrow(profiles_crossSec))
  for(i in 1:nrow(profiles_crossSec)){
    cat("\nGenerating ", i, "th group for cross-sectional recency testing data:\n")
    group_incid_crossSec = profiles_crossSec$Incidence[i]
    group_preval_crossSec = profiles_crossSec$Prevalence[i]
    
    group_panel_datalist = vector("list", length = n_sims)
    for(j in 1:n_sims){
      if(j %% 200 == 0){
        cat("Generating", j, "th replication\n")
      }
      group_num_obs_crossSec = num_obs_crossSec[i, j]
      if(group_num_obs_crossSec == 0){
        group_panel_datalist[[j]] = NULL
      }
      else{
        group_panel_data = generate.data(1, group_num_obs_crossSec, infection.function = infection.function, baseline_incidence = group_incid_crossSec, prevalence = group_preval_crossSec, rho = NA, phi.func = phi.func, times = 0, summarize = FALSE)[, c("pos", "rpos")]
        group_panel_data$sim = j
        
        group_panel_datalist[[j]] = group_panel_data
      }
    }
    group_panel_nsims = data.table::rbindlist(group_panel_datalist)
    group_panel_nsims$rInfection_pos = profiles_crossSec$rInfection_pos[i]
    group_panel_nsims$Receptive = profiles_crossSec$Receptive[i]
    group_panel_nsims$Anal_nocondom = profiles_crossSec$Anal_nocondom[i]
    group_panel_nsims$College = profiles_crossSec$College[i]
    out_panel_datalist[[i]] = group_panel_nsims
  }
  out_panel_data = data.table::rbindlist(out_panel_datalist)
  
  return(out_panel_data)
}


get_panel_trial = function(n_sims, sample_size_trial, profiles_trial, follow_time){
  
  # Within a column: number of observations of each group of individuals generated by
  # multinomial distribution
  # Different columns are different replications
  num_obs_trial = rmultinom(n_sims, size = sample_size_trial, prob = profiles_trial$Proportion)
  out_panel_datalist = vector("list", length = nrow(profiles_trial))
  for(i in 1:nrow(profiles_trial)){
    cat("\nGenerating ", i, "th group for the (trial) data from the target population:\n")
    group_incid_trial = profiles_trial$Incidence[i]
    
    group_panel_datalist = vector("list", length = n_sims)
    for(j in 1:n_sims){
      if(j %% 200 == 0){
        cat("Generating", j, "th replication\n")
      }
      group_num_obs_trial = num_obs_trial[i, j]
      if(group_num_obs_trial == 0){
        group_panel_datalist[[j]] = NULL
      }
      else{
        rand_num = runif(n = group_num_obs_trial)
        itime_trial = -log(rand_num) / group_incid_trial
        event=as.integer(itime_trial <= follow_time)
        itime_trial[which(event == 0)] = follow_time
        
        group_panel_data = data.frame(itime_trial=itime_trial, event=event)
        group_panel_data$sim = j
        
        group_panel_datalist[[j]] = group_panel_data
      }
    }
    group_panel_nsims = data.table::rbindlist(group_panel_datalist)
    group_panel_nsims$rInfection_pos = profiles_crossSec$rInfection_pos[i]
    group_panel_nsims$Receptive = profiles_crossSec$Receptive[i]
    group_panel_nsims$Anal_nocondom = profiles_crossSec$Anal_nocondom[i]
    group_panel_nsims$College = profiles_crossSec$College[i]
    out_panel_datalist[[i]] = group_panel_nsims
  }
  out_panel_data = data.table::rbindlist(out_panel_datalist)
  
  return(out_panel_data)
}
```


# Estimate the incidence ratio
```{r}
est_background_incidence = function(n_sims, bigT_crossSec,
                               sample_size_crossSec, sample_size_trial,
                               crossSec_data, trial_data, 
                               beta_ests, omega_ests,
                               beta_vars, omega_vars,
                               pop1 = "Screening Neg", pop2 = "Trial", 
                               bootstrap = TRUE, n_bootstrap=100,
                               form = population ~ rInfection_pos + Receptive + Anal_nocondom + College){
  incidence_lambda0_ests = sapply(1:n_sims, function(i){
    if(i %% 5 == 0){
      cat("\n", i)
    }
    crossSec_1sim = crossSec_data[which(crossSec_data$sim == i), ]
    crossSec_1sim[, sim := NULL]
    crossSec_1sim$population = 0
    
    trial_1sim = trial_data[which(trial_data$sim == i), ]
    trial_1sim[, sim := NULL]
    trial_1sim$population = 1
    lambda1 = sum(trial_1sim$event) / sum(trial_1sim$itime_trial)
    
    beta_est = beta_ests[i]
    omega_est = omega_ests[i]
    if(bootstrap){
      beta_var = beta_vars[[i]]
      omega_var = omega_vars[[i]]
      bs_crossSec_ids = replicate(n_bootstrap, sample(1:sample_size_crossSec, sample_size_crossSec, replace = TRUE))
      bs_trial_ids = replicate(n_bootstrap, sample(1:sample_size_trial, sample_size_trial, replace = TRUE))
      # bs_omega_ests = rnorm(n = n_bootstrap, mean = omega_est, sd = sqrt(omega_var))
      if(omega_var == 0){
        bs_omega_ests = rep(omega_est, n_bootstrap)
      }
      else{
        bs_omega_ests = exp(rnorm(n_bootstrap, log(omega_est), sqrt(omega_var)/omega_est))
      }
      if(beta_var == 0){
        bs_beta_ests = rep(beta_est, n_bootstrap)
      }
      else{
        # bs_beta_ests = rnorm(n = n_bootstrap, mean = beta_est, sd = sqrt(beta_var))
        bs_beta_ests = exp(rnorm(n_bootstrap, log(beta_est), sqrt(beta_var)/beta_est))
      }
    }
    
    if(pop1 != "All" | pop2 != "All"){
      if(pop1 == "Screening Neg" & pop2 == "Trial"){
        concact_1sim_lr = rbindlist(list(crossSec_1sim %>%
                                                 filter(pos == 0) %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, population),
          trial_1sim %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, population)))
        
        lrm = glm(formula = form, data = concact_1sim_lr, family = binomial())
        crossSec_1sim$weight = predict.glm(lrm, crossSec_1sim, type = "response")
        crossSec_1sim$weight = crossSec_1sim$weight / (1-crossSec_1sim$weight)
        
      
        lambda0 = sum(crossSec_1sim$weight * crossSec_1sim$pos * 
                      (crossSec_1sim$rpos - beta_est), na.rm = TRUE) /
                sum(crossSec_1sim$weight * (1 - crossSec_1sim$pos) * 
                        (omega_est - beta_est * bigT_crossSec))
        
        crossSec_1sim[, weight := NULL]
        
        if(bootstrap){
          bs_lambda0_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            crossSec_bs = crossSec_1sim[bs_crossSec_ids[, x], ]
            trial_bs = trial_1sim[bs_trial_ids[, x], ]
            
            # bs_lambda1 = sum(trial_bs$event) / sum(trial_bs$itime_trial)
            
            concact_bs_lr = rbindlist(list(crossSec_bs %>%
                                                 filter(pos == 0) %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, population),
              trial_bs %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, population)))
            
            bs_lrm = glm(formula = form, data = concact_bs_lr, family = binomial())
            crossSec_bs$weight = predict.glm(bs_lrm, crossSec_bs, type = "response")
            crossSec_bs$weight[which(crossSec_bs$weight == 1)] = 0.95
            crossSec_bs$weight = crossSec_bs$weight / (1-crossSec_bs$weight)
          
            bs_lambda0 = sum(crossSec_bs$weight * crossSec_bs$pos * 
                          (crossSec_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(crossSec_bs$weight * (1 - crossSec_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_crossSec))
            # return(bs_lambda1/bs_lambda0)
            return(bs_lambda0)
          })
          # return(c(lambda1/lambda0, sd(bs_ratio_ests), quantile(bs_ratio_ests, c(0.025,0.975)), sd(log(bs_ratio_ests))))
          return(c(lambda0, sd(bs_lambda0_ests), quantile(bs_lambda0_ests, c(0.025,0.975)), sd(log(bs_lambda0_ests))))
        }
        # return(lambda1/lambda0)
        return(lambda0)
      }
      
      
      else if(pop1 == "None" & pop2 == "None"){
        lambda0 = sum(crossSec_1sim$pos * 
                      (crossSec_1sim$rpos - beta_est), na.rm = TRUE) /
                sum((1 - crossSec_1sim$pos) * 
                        (omega_est - beta_est * bigT_crossSec))
        
        if(bootstrap){
          bs_lambda0_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            crossSec_bs = crossSec_1sim[bs_crossSec_ids[, x], ]
            trial_bs = trial_1sim[bs_trial_ids[, x], ]
            
            # bs_lambda1 = sum(trial_bs$event) / sum(trial_bs$itime_trial)
          
            bs_lambda0 = sum(crossSec_bs$pos * 
                          (crossSec_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum((1 - crossSec_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_crossSec))
            # return(bs_lambda1/bs_lambda0)
            return(bs_lambda0)
          })
          # return(c(lambda1/lambda0, sd(bs_ratio_ests), quantile(bs_ratio_ests, c(0.025,0.975)), sd(log(bs_ratio_ests))))
          return(c(lambda0, sd(bs_lambda0_ests), quantile(bs_lambda0_ests, c(0.025,0.975)), sd(log(bs_lambda0_ests))))
        }
        
        # return(lambda1/lambda0)
        return(lambda0)
      }
      else{
        stop("Re-enter your population variable")
      }
      
    }
    
    # Simulation with all of the weighting methods
    else{
      concact_1sim_lr = rbindlist(list(crossSec_1sim %>%
                                                 filter(pos == 0) %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, population),
          trial_1sim %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, population)))
        
      lrm = glm(formula = form, data = concact_1sim_lr, family = binomial())
      crossSec_1sim$weight = predict.glm(lrm, crossSec_1sim, type = "response")
      crossSec_1sim$weight = crossSec_1sim$weight / (1-crossSec_1sim$weight)
    
      lambda0_scrn_neg_trl = sum(crossSec_1sim$weight * crossSec_1sim$pos * 
                    (crossSec_1sim$rpos - beta_est), na.rm = TRUE) /
              sum(crossSec_1sim$weight * (1 - crossSec_1sim$pos) * 
                      (omega_est - beta_est * bigT_crossSec))
      
      lambda0_none_none = sum(crossSec_1sim$pos * 
                    (crossSec_1sim$rpos - beta_est), na.rm = TRUE) /
              sum((1 - crossSec_1sim$pos) * 
                      (omega_est - beta_est * bigT_crossSec))
      crossSec_1sim[, weight := NULL]
        
      
      if(bootstrap){
          bs_lambda0_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            crossSec_bs = crossSec_1sim[bs_crossSec_ids[, x], ]
            trial_bs = trial_1sim[bs_trial_ids[, x], ]
            
            # bs_lambda1 = sum(trial_bs$event) / sum(trial_bs$itime_trial)
            
            concact_bs_lr = rbindlist(list(crossSec_bs %>%
                                                 filter(pos == 0) %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, population),
              trial_bs %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, population)))
            
            bs_lrm = glm(formula = form, data = concact_bs_lr, family = binomial())
            crossSec_bs$weight = predict.glm(bs_lrm, crossSec_bs, type = "response")
            crossSec_bs$weight = crossSec_bs$weight / (1-crossSec_bs$weight)
          
            bs_lambda0_scrn_neg_trl = sum(crossSec_bs$weight * crossSec_bs$pos * 
                          (crossSec_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(crossSec_bs$weight * (1 - crossSec_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_crossSec))
            
            bs_lambda0_none_none = sum(crossSec_bs$pos * 
                          (crossSec_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum((1 - crossSec_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_crossSec))
            
            # return(c(bs_lambda1/bs_lambda0_scrn_neg_trl,
                     # bs_lambda1/bs_lambda0_none_none))
            return(c(bs_lambda0_scrn_neg_trl, bs_lambda0_none_none))
          })
          
          # bs_ratio_ests_scrn_neg_trl = bs_ratio_ests[1, ]
          # bs_ratio_ests_none_none = bs_ratio_ests[2, ]
          bs_lambda0_ests_scrn_neg_trl = bs_lambda0_ests[1, ]
          bs_lambda0_ests_none_none = bs_lambda0_ests[2, ]
          
          # return(c(lambda1/lambda0_scrn_neg_trl, sd(bs_ratio_ests_scrn_neg_trl), 
          #          quantile(bs_ratio_ests_scrn_neg_trl, c(0.025,0.975)), sd(log(bs_ratio_ests_scrn_neg_trl)),
          #          lambda1/lambda0_none_none, sd(bs_ratio_ests_none_none), 
          #          quantile(bs_ratio_ests_none_none, c(0.025,0.975)), sd(log(bs_ratio_ests_none_none))))
          return(c(lambda0_scrn_neg_trl, sd(bs_lambda0_ests_scrn_neg_trl),
                   quantile(bs_lambda0_ests_scrn_neg_trl, c(0.025,0.975)), sd(log(bs_lambda0_ests_scrn_neg_trl)),
                   lambda0_none_none, sd(bs_lambda0_ests_none_none),
                   quantile(bs_lambda0_ests_none_none, c(0.025,0.975)), sd(log(bs_lambda0_ests_none_none))))
      }
      # return(c(lambda1/lambda0_scrn_neg_trl, lambda1/lambda0_none_none))
      return(c(lambda0_scrn_neg_trl, lambda0_none_none))
    }
  })
  
  # return(incidence_ratio_ests)
  return(incidence_lambda0_ests)
}
```


```{r}
simulate_beta_study = function(n_long_infect, phi.func, minT, maxT){
  N = n_long_infect

  inf_times = runif(n=N, min=minT, max=maxT)
  recent = rbinom(n=N, size=1, p=phi.func(inf_times))
  
  beta_study = data.frame(inf_times=inf_times, recent=recent)
  return(beta_study)
}


simulate_beta_studies = function(nsims, n_long_infect, phi.func, minT, maxT){
  beta_studies = replicate(nsims, simulate_beta_study(n_long_infect, phi.func, minT, maxT),
                           simplify = FALSE)
  
  return(beta_studies)
}
```

```{r}
nsim_background_incidence_ests_bs = function(weight_methods, path){
  true_lambda0 = sum(profiles_crossSec$Incidence * profiles_trial$Proportion)
  output = data.frame(id = 1)
  full_output = data.frame(rep = 1:n_sims)
  if(list(c("All", "All")) %in% weight_methods){
    pop1 = "All"
    pop2 = "All"
    res = est_background_incidence(n_sims, bigT_crossSec,
                              sample_size_crossSec, sample_size_trial,
                              crossSec_data, trial_data, 
                              beta_ests, omega_ests,
                              beta_vars, omega_vars,
                              pop1 = pop1, pop2 = pop2, 
                              bootstrap = bootstrap, n_bootstrap=n_bootstrap,
                              form = form)
    
    lambda0_ests = res[1,]
    bs_ses = res[2,]
    bs_low_quantile = res[3,]
    bs_up_quantile = res[4,]
    bs_log_ses = res[5,]
    output$lambda0_est_avg = mean(lambda0_ests)
    output$true_lambda0 = true_lambda0
    output$lambda0_est_sd = sd(lambda0_ests)
    output$lambda0_bs_se_avg = mean(bs_ses)
    output$lambda0_bs_se_med = median(bs_ses)
    output$lambda0_bs_se_delta_avg = mean(bs_log_ses * lambda0_ests)
    output$lambda0_bs_se_delta_med = median(bs_log_ses * lambda0_ests)
    output$cover_rate_bs_se = mean(lambda0_ests - qnorm(0.975)*bs_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_ses >= true_lambda0)
    output$cover_rate_bs_quantile = mean(bs_low_quantile <= true_lambda0 & bs_up_quantile >= true_lambda0)
    output$cover_rate_bs_log_se = mean(log(lambda0_ests) - qnorm(0.975)*bs_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_log_ses)))
    
    full_output$lambda0_ests = lambda0_ests
    full_output$bs_ses = bs_ses
    full_output$bs_low_quantile = bs_low_quantile
    full_output$bs_up_quantile = bs_up_quantile
    full_output$bs_log_ses = bs_log_ses

    write.csv(output, paste0(path, "Screening Neg_Trial.csv"), row.names = FALSE)
    write.csv(full_output, paste0(path, "Screening Neg_Trial_full.csv"), row.names = FALSE)
    
    lambda0_ests = res[6,]
    bs_ses = res[7,]
    bs_low_quantile = res[8,]
    bs_up_quantile = res[9,]
    bs_log_ses = res[10,]
    output$lambda0_est_avg = mean(lambda0_ests)
    output$true_lambda0 = true_lambda0
    output$lambda0_est_sd = sd(lambda0_ests)
    output$lambda0_bs_se_avg = mean(bs_ses)
    output$lambda0_bs_se_med = median(bs_ses)
    output$lambda0_bs_se_delta_avg = mean(bs_log_ses * lambda0_ests)
    output$lambda0_bs_se_delta_med = median(bs_log_ses * lambda0_ests)
    output$cover_rate_bs_se = mean(lambda0_ests - qnorm(0.975)*bs_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_ses >= true_lambda0)
    output$cover_rate_bs_quantile = mean(bs_low_quantile <= true_lambda0 & bs_up_quantile >= true_lambda0)
    output$cover_rate_bs_log_se = mean(log(lambda0_ests) - qnorm(0.975)*bs_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_log_ses)))
    
    full_output$lambda0_ests = lambda0_ests
    full_output$bs_ses = bs_ses
    full_output$bs_low_quantile = bs_low_quantile
    full_output$bs_up_quantile = bs_up_quantile
    full_output$bs_log_ses = bs_log_ses

    write.csv(output, paste0(path, "None_None.csv"), row.names = FALSE)
    write.csv(full_output, paste0(path, "None_None_full.csv"), row.names = FALSE)
  }
  else{
    for(w in weight_methods){
      pop1 = w[1]
      pop2 = w[2]
      res = est_background_incidence(n_sims, bigT_crossSec, 
                               sample_size_crossSec, sample_size_trial,
                               crossSec_data, trial_data,
                               beta_ests, omega_ests,
                               beta_vars, omega_vars,
                               pop1 = pop1, pop2 = pop2, 
                               bootstrap = bootstrap, n_bootstrap=n_bootstrap,
                               form = form)
      
      lambda0_ests = res[1,]
      bs_ses = res[2,]
      bs_low_quantile = res[3,]
      bs_up_quantile = res[4,]
      bs_log_ses = res[5,]
      output$lambda0_est_avg = mean(lambda0_ests)
      output$true_lambda0 = true_lambda0
      output$lambda0_est_sd = sd(lambda0_ests)
      output$lambda0_bs_se_avg = mean(bs_ses)
      output$lambda0_bs_se_med = median(bs_ses)
      output$lambda0_bs_se_delta_avg = mean(bs_log_ses * lambda0_ests)
      output$lambda0_bs_se_delta_med = median(bs_log_ses * lambda0_ests)
      output$cover_rate_bs_se = mean(lambda0_ests - qnorm(0.975)*bs_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_ses >= true_lambda0)
      output$cover_rate_bs_quantile = mean(bs_low_quantile <= true_lambda0 & bs_up_quantile >= true_lambda0)
      output$cover_rate_bs_log_se = mean(log(lambda0_ests) - qnorm(0.975)*bs_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_log_ses)))
      
      full_output$lambda0_ests = lambda0_ests
      full_output$bs_ses = bs_ses
      full_output$bs_low_quantile = bs_low_quantile
      full_output$bs_up_quantile = bs_up_quantile
      full_output$bs_log_ses = bs_log_ses

      write.csv(output, paste0(path, pop1,"_", pop2, ".csv"), row.names = FALSE)
      write.csv(full_output, paste0(path, pop1,"_", pop2, "_full.csv"), row.names = FALSE)
    }
  }
}
```

```{r}
set.seed(1024)
library(readr)
follow_time = 3
true_incid_ratio = 2

profiles_crossSec = read_csv("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/Simulation/Data/screening_data.csv")
profiles_trial = read_csv("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/Simulation/Data/trial_data.csv")
profiles_trial$Incidence = profiles_crossSec$Incidence/true_incid_ratio
n_sims = 500
bootstrap = TRUE
n_bootstrap = 500
phi.func = get.phi.function(176, 95.72, phi_frr = 1e-10)

bigT_crossSec = 2

infection.function = infections.con

n_long_infect = 1500
beta_studies = simulate_beta_studies(n_sims, n_long_infect, phi.func, minT = bigT_crossSec, maxT = 12)
betas = sapply(beta_studies, function(study){
  N = nrow(study)
  beta = sum(study$recent) / N
  beta_var = beta * (1 - beta) / N
  return(list(beta=beta, beta_var=beta_var))
})
beta_ests = unlist(betas["beta",])
beta_vars = unlist(betas["beta_var",])


omega_studies = simulate_studies(n_sims, phi.func)
omega_studies = sapply(omega_studies, function(study){
  setnames(study, c("id", "ui", "ri"))
  study[study$ui == 0, "ui"] = 0.01
  study = study[which(study$ui <= 2), ]
  return(study)
}, simplify = FALSE)

suppressWarnings(invisible(capture.output(omegas <- sapply(omega_studies, function(study){
  estimate.phi(phidat=study, maxT=bigT_crossSec, bigT=bigT_crossSec, min_dt=TRUE,
               formula="ri ~ poly(log(ui), raw=T, degree=4)", family=binomial(link="logit"),
               use_geese=TRUE, plot_phi=FALSE)
}))))

omega_ests = unlist(omegas["omega",])
omega_vars = unlist(omegas["omega_var", ])


weight_methods = list(c("All", "All"))
form = population ~ rInfection_pos + Receptive + Anal_nocondom + College


for(size in c("largeSize", "smallSize")){
  set.seed(1024)
  if(size == "largeSize"){
    sample_size_crossSec =5000
    sample_size_trial = 2500
    out_path = "./NoSubtype_BS_ParBS_largeSize/"
  }
  else{
    sample_size_crossSec =2500
    sample_size_trial = 1250
    out_path = "./NoSubtype_BS_ParBS_smallSize/"
  }
  crossSec_data = get_panel_crossSec(n_sims, sample_size_crossSec,
                                   profiles_crossSec, infection.function, phi.func,
                                   bigT_crossSec)
  trial_data = get_panel_trial(n_sims, sample_size_trial, profiles_trial, follow_time)
  nsim_background_incidence_ests_bs(weight_methods, out_path)
}
```