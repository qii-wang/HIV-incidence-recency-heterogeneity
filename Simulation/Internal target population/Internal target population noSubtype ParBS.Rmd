---
title: "Internal target population noSubtype ParBS"
author: "Qi Wang"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if(!require(XSRecency)){
  devtools::install("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/XSRecency-pt-functions") 
}
```

# Generating data for cross sectional and target (trial) populations
```{r}
library(XSRecency)
library(geepack)
library(data.table)
library(dplyr)
YEAR2DAY=365.25

get.phi.function = function(window.period, shadow.period, phi_tfrr = NULL, 
                            phi_frr = NULL, phi_norm_mu = NULL, phi_norm_sd = NULL, 
                            phi_norm_div = NULL, phi_pnorm_mu = NULL, phi_pnorm_sd = NULL, 
                            phi_pnorm_div = NULL){
  # Get the gamma parameters and baseline phi function
  params = get.gamma.params(window=window.period/YEAR2DAY, shadow=shadow.period/YEAR2DAY)
  # Set up each type of phi function, will be overwritten
  phi.none = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phi.const = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phi.norm = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  phit.pnorm = function(t) 1-pgamma(t, shape = params[1], rate = params[2])
  
  phi.func = phi.none
  
  # Get the phi function with constant FRR either past a certain time
  # or fixed after it hits some value.
  if(!is.null(phi_tfrr) | !is.null(phi_frr)){
    if(!is.null(phi_tfrr)){
      ttime = phi_tfrr
      tval = phi.none(ttime)
    }
    if(!is.null(phi_frr)){
      tau = 12
      tval = phi_frr
      ttime = uniroot(function(t) phi.none(t) - tval, interval=c(0, tau))$root
      cat(ttime)
    }
    phi.const = function(t, ...) phi.none(t)*(t <= ttime) + tval*(t > ttime)
    phi.func = phi.const
  }
  if(!is.null(phi_norm_mu)){
    phi.norm = function(t) phi.const(t) + dnorm(t-phi_norm_mu, mean=0, sd=phi_norm_sd) / phi_norm_div
    phi.func = phi.norm
  }
  if(!is.null(phi_pnorm_mu)){
    phi.pnorm = function(t) phi.const(t) + pnorm(t-phi_pnorm_mu, mean=0, sd=phi_pnorm_sd) / phi_pnorm_div
    phi.func = phi.pnorm
  }
  return(phi.func)
}


get_panel_data = function(n_sims, sample_size_screen, profiles_screen, 
                          infection.function, phi.func, bigT_screen, 
                          sample_size_trial, profiles_trial, follow_time,
                          trunc_max = 0.95){
  enroll_prob = profiles_trial$Proportion / ((1 - profiles_screen$Prevalence) * profiles_screen$Proportion) * sample_size_trial / sample_size_screen
  if(max(enroll_prob) >= 1){
    large_prob = enroll_prob[which(enroll_prob >= 1)]
    trunc_min = max(enroll_prob[which(enroll_prob < (trunc_max - 0.05))]) + 0.05
    enroll_prob[which(enroll_prob >= 1)] = trunc_min + (trunc_max - trunc_min)/
      (max(large_prob)-min(large_prob))* (large_prob-min(large_prob))
    cat("Truncation max:", trunc_max, " Truncation min:", trunc_min, "\n")
  }
  cat("The probability of enrollment into trial:", enroll_prob, "\n\n")
  
  # Within a column: number of observations of each group of individuals generated by
  # multinomial distribution
  # Different columns are different replications
  num_obs_screen = rmultinom(n_sims, size = sample_size_screen, prob = profiles_screen$Proportion)
  out_panel_datalist = vector("list", length = nrow(profiles_screen))
  for(i in 1:nrow(profiles_screen)){
    cat("\nGenerating ", i, "th group:\n")
    group_incid_screen = profiles_screen$Incidence[i]
    group_preval_screen = profiles_screen$Prevalence[i]
    group_propor_screen = profiles_screen$Proportion[i]
    group_incid_trial = profiles_trial$Incidence[i]
    group_propor_trial = profiles_trial$Proportion[i]
    group_enroll_prob = enroll_prob[i]
    
    group_panel_datalist = vector("list", length = n_sims)
    for(j in 1:n_sims){
      if(j %% 200 == 0){
        cat("Generating", j, "th replication\n")
      }
      group_num_obs_screen = num_obs_screen[i, j]
      if(group_num_obs_screen == 0){
        group_panel_datalist[[j]] = NULL
      }
      else{
        group_panel_data = generate.data(1, group_num_obs_screen, infection.function = infection.function, baseline_incidence = group_incid_screen, prevalence = group_preval_screen, rho = NA, phi.func = phi.func, times = 0, summarize = FALSE)[, c("pos", "rpos")]
        group_panel_data$sim = j
        group_panel_data$intrial = 0
        group_panel_data$itime_trial = NA
        
        group_num_neg_screen = sum(1 - group_panel_data$pos)
        group_num_obs_trial = rbinom(n = 1, size = group_num_neg_screen, prob = group_enroll_prob)
        rand_num = runif(n = group_num_obs_trial)
        infec_time_trial = -log(rand_num) / group_incid_trial
        group_panel_data$intrial[which(group_panel_data$pos == 0)] = c(rep(1, group_num_obs_trial), rep(0, group_num_neg_screen - group_num_obs_trial))
        
        group_panel_data$itime_trial[which(group_panel_data$intrial == 1)] = infec_time_trial
        group_panel_data$event = as.integer(group_panel_data$itime_trial <= follow_time)
        group_panel_data$itime_trial[which(group_panel_data$itime_trial > follow_time)] = follow_time
        
        group_panel_datalist[[j]] = group_panel_data
      }
      if(j %% 200 == 0){
        cat("\n")
      }
    }
    group_panel_nsims = data.table::rbindlist(group_panel_datalist)
    group_panel_nsims$rInfection_pos = profiles_screen$rInfection_pos[i]
    group_panel_nsims$Receptive = profiles_screen$Receptive[i]
    group_panel_nsims$Anal_nocondom = profiles_screen$Anal_nocondom[i]
    group_panel_nsims$College = profiles_screen$College[i]
    out_panel_datalist[[i]] = group_panel_nsims
  }
  out_panel_data = data.table::rbindlist(out_panel_datalist)
  
  return(list(panel_data = out_panel_data, enroll_prob = enroll_prob, trial_proportion = enroll_prob * sample_size_screen / sample_size_trial * ((1 - profiles_screen$Prevalence) * profiles_screen$Proportion)))
}
```


# Estimate incidence in target population and efficacy
```{r}
est_incidence = function(n_sims, sample_size_screen,
                               panel_data, beta_ests, omega_ests,
                               beta_vars, omega_vars,
                               pop1 = "Screening Neg & Rec", pop2 = "Trial", 
                               bootstrap = TRUE, n_bootstrap=100,
                               form = population ~ rInfection_pos + Receptive + Anal_nocondom + College){
  incidence_ests = sapply(1:n_sims, function(i){
    if(i %% 5 == 0){
      cat("\n", i, "\n")
    }
    panel_1sim = panel_data[which(panel_data$sim == i), ]
    panel_1sim[, sim := NULL]
    lambda1 = sum(panel_1sim$event, na.rm = TRUE) / sum(panel_1sim$itime_trial, na.rm = TRUE)
    beta_est = beta_ests[i]
    omega_est = omega_ests[i]
    if(bootstrap){
      bs_panel_ids = replicate(n_bootstrap, sample(1:sample_size_screen, sample_size_screen, replace = TRUE))
      beta_var = beta_vars[[i]]
      omega_var = omega_vars[[i]]
      if(omega_var == 0){
        bs_omega_ests = rep(omega_est, n_bootstrap)
      }
      else{
        bs_omega_ests = exp(rnorm(n_bootstrap, log(omega_est), sqrt(omega_var)/omega_est))
      }
      if(beta_var == 0){
        bs_beta_ests = rep(beta_est, n_bootstrap)
      }
      else{
        # bs_beta_ests = rnorm(n = n_bootstrap, mean = beta_est, sd = sqrt(beta_var))
        bs_beta_ests = exp(rnorm(n_bootstrap, log(beta_est), sqrt(beta_var)/beta_est))
      }
    }
    
    if(pop1 != "All" | pop2 != "All"){
      if(pop1 == "Screening Neg" & pop2 == "Trial"){
        
        panel_1sim_lr = panel_1sim %>% filter(pos == 0) %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, intrial)
        colnames(panel_1sim_lr)[ncol(panel_1sim_lr)] = "population"
        
        lrm = glm(formula = form, data = panel_1sim_lr, family = binomial())
        panel_1sim$weight = predict.glm(lrm, panel_1sim, type = "response")
      
        lambda0 = sum(panel_1sim$weight * panel_1sim$pos * 
                      (panel_1sim$rpos - beta_est), na.rm = TRUE) /
                sum(panel_1sim$weight * (1 - panel_1sim$pos) * 
                        (omega_est - beta_est * bigT_screen), na.rm = TRUE)
        panel_1sim[, weight := NULL]
        
        if(bootstrap){
          bs_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            panel_bs = panel_1sim[bs_panel_ids[, x], ]
            bs_lambda1 = sum(panel_bs$event, na.rm = TRUE) / sum(panel_bs$itime_trial, na.rm = TRUE)
            panel_bs_lr = panel_bs %>% filter(pos == 0) %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, intrial)
            colnames(panel_bs_lr)[ncol(panel_bs_lr)] = "population"
            
            bs_lrm = glm(formula = form, data = panel_bs_lr, family = binomial())
            panel_bs$weight = predict.glm(bs_lrm, panel_bs, type = "response")
          
            bs_lambda0 = sum(panel_bs$weight * panel_bs$pos * 
                          (panel_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(panel_bs$weight * (1 - panel_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_screen), na.rm = TRUE)
            return(bs_lambda0, 1-bs_lambda1/bs_lambda0)
          })
          bs_lambda0_ests = bs_ests[1, ]
          bs_efficacy_ests = bs_ests[2, ]
          return(c(lambda0, sd(bs_lambda0_ests), quantile(bs_lambda0_ests, c(0.025,0.975)), sd(log(bs_lambda0_ests)),
                   1-lambda1/lambda0, sd(bs_efficacy_ests), quantile(bs_efficacy_ests, c(0.025,0.975)), sd(log(1-bs_efficacy_ests))))
        }
      
        return(lambda0, 1-lambda1/lambda0)
      }
      
      
      else if(pop1 == "None" & pop2 == "None"){
        panel_1sim$weight = 1
      
        lambda0 = sum(panel_1sim$weight * panel_1sim$pos * 
                      (panel_1sim$rpos - beta_est), na.rm = TRUE) /
                sum(panel_1sim$weight * (1 - panel_1sim$pos) * 
                        (omega_est - beta_est * bigT_screen), na.rm = TRUE)
        panel_1sim[, weight := NULL]
        
        if(bootstrap){
          bs_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            panel_bs = panel_1sim[bs_panel_ids[, x], ]
            
            bs_lambda1 = sum(panel_bs$event, na.rm = TRUE) / sum(panel_bs$itime_trial, na.rm = TRUE)
            panel_bs$weight = 1
          
            bs_lambda0 = sum(panel_bs$weight * panel_bs$pos * 
                          (panel_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(panel_bs$weight * (1 - panel_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_screen), na.rm = TRUE)
            return(bs_lambda0, 1-bs_lambda1/bs_lambda0)
          })
          bs_lambda0_ests = bs_ests[1, ]
          bs_efficacy_ests = bs_ests[2, ]
          return(c(lambda0, sd(bs_lambda0_ests), quantile(bs_lambda0_ests, c(0.025,0.975)), sd(log(bs_lambda0_ests)),
                   1-lambda1/lambda0, sd(bs_efficacy_ests), quantile(bs_efficacy_ests, c(0.025,0.975)), sd(log(1-bs_efficacy_ests))))
        }
      
        return(lambda0, 1-lambda1/lambda0)
      }
      else{
        stop("Re-enter your population variable")
      }
      
    }
    
    # Simulation with all of the weighting methods
    else{
      panel_1sim_lr = panel_1sim %>% filter(pos == 0) %>%
          select(rInfection_pos, Receptive, Anal_nocondom, College, intrial)
      colnames(panel_1sim_lr)[ncol(panel_1sim_lr)] = "population"
      lrm = glm(formula = form, data = panel_1sim_lr, family = binomial())
      panel_1sim$weight = predict.glm(lrm, panel_1sim, type = "response")
      lambda0_scrn_neg_trl = sum(panel_1sim$weight * panel_1sim$pos * 
                    (panel_1sim$rpos - beta_est), na.rm = TRUE) /
              sum(panel_1sim$weight * (1 - panel_1sim$pos) * 
                      (omega_est - beta_est * bigT_screen), na.rm = TRUE)
      
      
      panel_1sim$weight = 1
      lambda0_none_none = sum(panel_1sim$weight * panel_1sim$pos * 
                    (panel_1sim$rpos - beta_est), na.rm = TRUE) /
              sum(panel_1sim$weight * (1 - panel_1sim$pos) * 
                      (omega_est - beta_est * bigT_screen), na.rm = TRUE)
      panel_1sim[, weight := NULL]
        
      
      if(bootstrap){
          bs_ests = sapply(1:n_bootstrap, function(x){
            bs_omega_est = bs_omega_ests[x]
            bs_beta_est = bs_beta_ests[x]
            
            # Get the bootstrap sample
            panel_bs = panel_1sim[bs_panel_ids[, x], ]
            bs_lambda1 = sum(panel_bs$event, na.rm = TRUE) / sum(panel_bs$itime_trial, na.rm = TRUE)
            
            
            panel_bs_lr = panel_bs %>% filter(pos == 0) %>%
              select(rInfection_pos, Receptive, Anal_nocondom, College, intrial)
            colnames(panel_bs_lr)[ncol(panel_bs_lr)] = "population"
            bs_lrm = glm(formula = form, data = panel_bs_lr, family = binomial())
            panel_bs$weight = predict.glm(bs_lrm, panel_bs, type = "response")
            bs_lambda0_scrn_neg_trl = sum(panel_bs$weight * panel_bs$pos * 
                          (panel_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(panel_bs$weight * (1 - panel_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_screen), na.rm = TRUE)
            
            
            panel_bs$weight = 1
            bs_lambda0_none_none = sum(panel_bs$weight * panel_bs$pos * 
                          (panel_bs$rpos - bs_beta_est), na.rm = TRUE) /
                    sum(panel_bs$weight * (1 - panel_bs$pos) * 
                            (bs_omega_est - bs_beta_est * bigT_screen), na.rm = TRUE)
            
            return(c(bs_lambda0_scrn_neg_trl,
                     bs_lambda0_none_none,
                     1-bs_lambda1/bs_lambda0_scrn_neg_trl,
                     1-bs_lambda1/bs_lambda0_none_none))
          })
          
          bs_lambda0_ests_scrn_neg_trl = bs_ests[1, ]
          bs_lambda0_ests_none_none = bs_ests[2, ]
          bs_efficacy_ests_scrn_neg_trl = bs_ests[3, ]
          bs_efficacy_ests_none_none = bs_ests[4, ]
          
          
          return(c(lambda0_scrn_neg_trl, sd(bs_lambda0_ests_scrn_neg_trl), 
                   quantile(bs_lambda0_ests_scrn_neg_trl, c(0.025,0.975)), sd(log(bs_lambda0_ests_scrn_neg_trl)),
                   lambda0_none_none, sd(bs_lambda0_ests_none_none), 
                   quantile(bs_lambda0_ests_none_none, c(0.025,0.975)), sd(log(bs_lambda0_ests_none_none)),
                   1-lambda1/lambda0_scrn_neg_trl, sd(bs_efficacy_ests_scrn_neg_trl), 
                   quantile(bs_efficacy_ests_scrn_neg_trl, c(0.025,0.975)), sd(log(1-bs_efficacy_ests_scrn_neg_trl)),
                   1-lambda1/lambda0_none_none, sd(bs_efficacy_ests_none_none), 
                   quantile(bs_efficacy_ests_none_none, c(0.025,0.975)), sd(log(1-bs_efficacy_ests_none_none))))
      }
      return(c(lambda0_scrn_neg_trl, lambda0_none_none,
               1-lambda1/lambda0_scrn_neg_trl, 1-lambda1/lambda0_none_none))
    }
  })
  
  return(incidence_ests)
}
```


# Simulate additional studies for estimating FRR and MDRI
```{r}
simulate_beta_study = function(n_long_infect, phi.func, minT, maxT){
  N = n_long_infect

  inf_times = runif(n=N, min=minT, max=maxT)
  recent = rbinom(n=N, size=1, p=phi.func(inf_times))
  
  beta_study = data.frame(inf_times=inf_times, recent=recent)
  return(beta_study)
}


simulate_beta_studies = function(nsims, n_long_infect, phi.func, minT, maxT){
  beta_studies = replicate(nsims, simulate_beta_study(n_long_infect, phi.func, minT, maxT),
                           simplify = FALSE)
  
  return(beta_studies)
}
```


# Summarize results
```{r}
nsim_ests_bs = function(weight_methods, path){
  true_lambda0 = sum(panel_data_res$trial_proportion * profiles_screen$Incidence)/sum(panel_data_res$trial_proportion)
  true_efficacy = 1 - 1/true_incid_ratio
  output = data.frame(parameter = c("lambda0", "efficacy"))
  full_output = data.frame(rep = c(1:n_sims, 1:n_sims), parameter = rep(c("lambda0", "efficacy"), each = n_sims))
  if(list(c("All", "All")) %in% weight_methods){
    pop1 = "All"
    pop2 = "All"
    res = est_incidence(n_sims, sample_size_screen,
                               panel_data, beta_ests, omega_ests,
                               beta_vars, omega_vars,
                               pop1 = pop1, pop2 = pop2, 
                               bootstrap = bootstrap, n_bootstrap=n_bootstrap,
                               form = form)

    lambda0_ests = res[1,]
    bs_lambda0_ses = res[2,]
    bs_lambda0_low_quantile = res[3,]
    bs_lambda0_up_quantile = res[4,]
    bs_lambda0_log_ses = res[5,]
    efficacy_ests = res[11,]
    bs_efficacy_ses = res[12,]
    bs_efficacy_low_quantile = res[13,]
    bs_efficacy_up_quantile = res[14,]
    bs_efficacy_log_ses = res[15,]
    output$est_avg = c(mean(lambda0_ests), mean(efficacy_ests))
    output$true_val = c(true_lambda0, true_efficacy)
    output$est_sd = c(sd(lambda0_ests), sd(efficacy_ests))
    output$bs_se_avg = c(mean(bs_lambda0_ses), mean(bs_efficacy_ses))
    output$bs_se_med = c(median(bs_lambda0_ses), median(bs_efficacy_ses))
    output$bs_se_delta_avg = c(mean(bs_lambda0_log_ses * lambda0_ests), mean(bs_efficacy_log_ses * efficacy_ests))
    output$bs_se_delta_med = c(median(bs_lambda0_log_ses * lambda0_ests), median(bs_efficacy_log_ses * efficacy_ests))
    output$cover_rate_bs_se = c(mean(lambda0_ests - qnorm(0.975)*bs_lambda0_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_lambda0_ses >= true_lambda0), 
                                mean(efficacy_ests - qnorm(0.975)*bs_efficacy_ses <= true_efficacy & efficacy_ests + qnorm(0.975)*bs_efficacy_ses >= true_efficacy))
    output$cover_rate_bs_quantile = c(mean(bs_lambda0_low_quantile <= true_lambda0 & bs_lambda0_up_quantile >= true_lambda0), 
                                      mean(bs_efficacy_low_quantile <= true_efficacy & bs_efficacy_up_quantile >= true_efficacy))
    output$cover_rate_bs_log_se = c(mean(log(lambda0_ests) - qnorm(0.975)*bs_lambda0_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_lambda0_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_lambda0_log_ses))),
                                    mean(log(1-efficacy_ests) - qnorm(0.975)*bs_efficacy_log_ses <= log(1-true_efficacy) & log(1-efficacy_ests) + qnorm(0.975)*bs_efficacy_log_ses >= log(1-true_efficacy) & 1 - efficacy_ests > 0 & (!is.na(bs_efficacy_log_ses))))
    
    full_output$ests = c(lambda0_ests, efficacy_ests)
    full_output$bs_ses = c(bs_lambda0_ses, bs_efficacy_ses)
    full_output$bs_low_quantile = c(bs_lambda0_low_quantile, bs_efficacy_low_quantile)
    full_output$bs_up_quantile = c(bs_lambda0_up_quantile, bs_efficacy_up_quantile)
    full_output$bs_log_ses = c(bs_lambda0_log_ses, bs_efficacy_log_ses)

    write.csv(output, paste0(path, "Screening Neg_Trial.csv"), row.names = FALSE)
    write.csv(full_output, paste0(path, "Screening Neg_Trial_full.csv"), row.names = FALSE)

    lambda0_ests = res[6,]
    bs_lambda0_ses = res[7,]
    bs_lambda0_low_quantile = res[8,]
    bs_lambda0_up_quantile = res[9,]
    bs_lambda0_log_ses = res[10,]
    efficacy_ests = res[16,]
    bs_efficacy_ses = res[17,]
    bs_efficacy_low_quantile = res[18,]
    bs_efficacy_up_quantile = res[19,]
    bs_efficacy_log_ses = res[20,]
    output$est_avg = c(mean(lambda0_ests), mean(efficacy_ests))
    output$true_val = c(true_lambda0, true_efficacy)
    output$est_sd = c(sd(lambda0_ests), sd(efficacy_ests))
    output$bs_se_avg = c(mean(bs_lambda0_ses), mean(bs_efficacy_ses))
    output$bs_se_med = c(median(bs_lambda0_ses), median(bs_efficacy_ses))
    output$bs_se_delta_avg = c(mean(bs_lambda0_log_ses * lambda0_ests), mean(bs_efficacy_log_ses * efficacy_ests))
    output$bs_se_delta_med = c(median(bs_lambda0_log_ses * lambda0_ests), median(bs_efficacy_log_ses * efficacy_ests))
    output$cover_rate_bs_se = c(mean(lambda0_ests - qnorm(0.975)*bs_lambda0_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_lambda0_ses >= true_lambda0), 
                                mean(efficacy_ests - qnorm(0.975)*bs_efficacy_ses <= true_efficacy & efficacy_ests + qnorm(0.975)*bs_efficacy_ses >= true_efficacy))
    output$cover_rate_bs_quantile = c(mean(bs_lambda0_low_quantile <= true_lambda0 & bs_lambda0_up_quantile >= true_lambda0), 
                                      mean(bs_efficacy_low_quantile <= true_efficacy & bs_efficacy_up_quantile >= true_efficacy))
    output$cover_rate_bs_log_se = c(mean(log(lambda0_ests) - qnorm(0.975)*bs_lambda0_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_lambda0_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_lambda0_log_ses))),
                                    mean(log(1-efficacy_ests) - qnorm(0.975)*bs_efficacy_log_ses <= log(1-true_efficacy) & log(1-efficacy_ests) + qnorm(0.975)*bs_efficacy_log_ses >= log(1-true_efficacy) & 1 - efficacy_ests > 0 & (!is.na(bs_efficacy_log_ses))))
    
    full_output$ests = c(lambda0_ests, efficacy_ests)
    full_output$bs_ses = c(bs_lambda0_ses, bs_efficacy_ses)
    full_output$bs_low_quantile = c(bs_lambda0_low_quantile, bs_efficacy_low_quantile)
    full_output$bs_up_quantile = c(bs_lambda0_up_quantile, bs_efficacy_up_quantile)
    full_output$bs_log_ses = c(bs_lambda0_log_ses, bs_efficacy_log_ses)

    write.csv(output, paste0(path, "None_None.csv"), row.names = FALSE)
    write.csv(full_output, paste0(path, "None_None_full.csv"), row.names = FALSE)
  }
  else{
    for(w in weight_methods){
      pop1 = w[1]
      pop2 = w[2]
      res = est_incidence(n_sims, sample_size_screen,
                               panel_data, beta_ests, omega_ests,
                               beta_vars, omega_vars,
                               pop1 = pop1, pop2 = pop2, 
                               bootstrap = bootstrap, n_bootstrap=n_bootstrap,
                               form = form)
      
      lambda0_ests = res[1,]
      bs_lambda0_ses = res[2,]
      bs_lambda0_low_quantile = res[3,]
      bs_lambda0_up_quantile = res[4,]
      bs_lambda0_log_ses = res[5,]
      efficacy_ests = res[6,]
      bs_efficacy_ses = res[7,]
      bs_efficacy_low_quantile = res[8,]
      bs_efficacy_up_quantile = res[9,]
      bs_efficacy_log_ses = res[10,]
      output$est_avg = c(mean(lambda0_ests), mean(efficacy_ests))
      output$true_val = c(true_lambda0, true_efficacy)
      output$est_sd = c(sd(lambda0_ests), sd(efficacy_ests))
      output$bs_se_avg = c(mean(bs_lambda0_ses), mean(bs_efficacy_ses))
      output$bs_se_med = c(median(bs_lambda0_ses), median(bs_efficacy_ses))
      output$bs_se_delta_avg = c(mean(bs_lambda0_log_ses * lambda0_ests), mean(bs_efficacy_log_ses * efficacy_ests))
      output$bs_se_delta_med = c(median(bs_lambda0_log_ses * lambda0_ests), median(bs_efficacy_log_ses * efficacy_ests))
      output$cover_rate_bs_se = c(mean(lambda0_ests - qnorm(0.975)*bs_lambda0_ses <= true_lambda0 & lambda0_ests + qnorm(0.975)*bs_lambda0_ses >= true_lambda0), 
                                  mean(efficacy_ests - qnorm(0.975)*bs_efficacy_ses <= true_efficacy & efficacy_ests + qnorm(0.975)*bs_efficacy_ses >= true_efficacy))
      output$cover_rate_bs_quantile = c(mean(bs_lambda0_low_quantile <= true_lambda0 & bs_lambda0_up_quantile >= true_lambda0), 
                                        mean(bs_efficacy_low_quantile <= true_efficacy & bs_efficacy_up_quantile >= true_efficacy))
      output$cover_rate_bs_log_se = c(mean(log(lambda0_ests) - qnorm(0.975)*bs_lambda0_log_ses <= log(true_lambda0) & log(lambda0_ests) + qnorm(0.975)*bs_lambda0_log_ses >= log(true_lambda0) & lambda0_ests > 0 & (!is.na(bs_lambda0_log_ses))),
                                    mean(log(1-efficacy_ests) - qnorm(0.975)*bs_efficacy_log_ses <= log(1-true_efficacy) & log(1-efficacy_ests) + qnorm(0.975)*bs_efficacy_log_ses >= log(1-true_efficacy) & 1 - efficacy_ests > 0 & (!is.na(bs_efficacy_log_ses))))
      
      full_output$ests = c(lambda0_ests, efficacy_ests)
      full_output$bs_ses = c(bs_lambda0_ses, bs_efficacy_ses)
      full_output$bs_low_quantile = c(bs_lambda0_low_quantile, bs_efficacy_low_quantile)
      full_output$bs_up_quantile = c(bs_lambda0_up_quantile, bs_efficacy_up_quantile)
      full_output$bs_log_ses = c(bs_lambda0_log_ses, bs_efficacy_log_ses)
      
      write.csv(output, paste0(path, pop1,"_", pop2, ".csv"), row.names = FALSE)
      write.csv(full_output, paste0(path, pop1,"_", pop2, "_full.csv"), row.names = FALSE)
    }
  }
}

```

# Run the simulations
```{r}
library(readr)
set.seed(1024)
follow_time = 3
true_incid_ratio = 2

profiles_screen = read_csv("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/Simulation/Data/screening_data.csv")
profiles_trial = read_csv("/Users/qi/Desktop/GitHub/HIV-incidence-recency-heterogeneity/Simulation/Data/trial_data.csv")
profiles_trial$Incidence = profiles_screen$Incidence/true_incid_ratio
n_sims = 500
bootstrap = TRUE
n_bootstrap = 500
phi.func = get.phi.function(176, 95.72, phi_frr = 1e-10)
bigT_screen = 2
infection.function = infections.con


n_long_infect = 1500
beta_studies = simulate_beta_studies(n_sims, n_long_infect, phi.func, minT = bigT_screen, maxT = 12)
betas = sapply(beta_studies, function(study){
  N = nrow(study)
  beta = sum(study$recent) / N
  beta_var = beta * (1 - beta) / N
  return(list(beta=beta, beta_var=beta_var))
})
beta_ests = unlist(betas["beta",])
beta_vars = unlist(betas["beta_var",])


omega_studies = simulate_studies(n_sims, phi.func)
omega_studies = sapply(omega_studies, function(study){
  setnames(study, c("id", "ui", "ri"))
  study[study$ui == 0, "ui"] = 0.01
  study = study[which(study$ui <= 2), ]
  return(study)
}, simplify = FALSE)

suppressWarnings(invisible(capture.output(omegas <- sapply(omega_studies, function(study){
  estimate.phi(phidat=study, maxT=bigT_screen, bigT=bigT_screen, min_dt=TRUE,
               formula="ri ~ poly(log(ui), raw=T, degree=4)", family=binomial(link="logit"),
               use_geese=TRUE, plot_phi=FALSE)
}))))

omega_ests = unlist(omegas["omega",])
omega_vars = unlist(omegas["omega_var", ])


weight_methods = list(c("All", "All"))
form = population ~ rInfection_pos + Receptive + Anal_nocondom + College


for(size in c("largeSize", "smallSize")){
  set.seed(2048)
  if(size == "largeSize"){
    sample_size_screen = 5000
    sample_size_trial = 2500
    out_path = "./NoSubtype_BS_ParBS_largeSize/"
  }
  else{
    sample_size_screen =2500
    sample_size_trial = 1250
    out_path = "./NoSubtype_BS_ParBS_smallSize/"
  }
  panel_data_res = get_panel_data(n_sims, sample_size_screen, profiles_screen,
                          infection.function, phi.func, bigT_screen,
                          sample_size_trial, profiles_trial, follow_time)
  panel_data = panel_data_res$panel_data
  nsim_ests_bs(weight_methods, out_path)
}
```
